"=============================================================================
"    Description: key map
"         Author:
"=============================================================================
"*****************************************************************************
"
"*****************************************************************************
" input number
" nmap <silent>;bm :ls<CR>:buf

noremap j gj
noremap k gk

" Shift + h で左端
noremap <S-h>   ^
" Shift + lで右端にカーソル移動
noremap <S-l>   $

noremap <S-j>   }
noremap <S-k>   {
" noremap m  %
" バッファ全体のインデント整理
nnoremap == gg=G''
" オムニ補完をキー一発でできるように設定
inoremap <C-f> <C-x><C-o>

" カーソルから行末までコピー
" vi との互換のために行全体をコピーする仕様らしいが、
" 他のキー(C,D)との兼ね合いも含めて変更する。
nnoremap Y y$
" 改行を含めないで全体をヤンク
nnoremap yl ^y$

" ビジュアルモードで < > キーによるインデント後にビジュアルモードが解除されないようにする
vnoremap < <gv
vnoremap > >gv

" poslist
" 履歴を移動するマッピング
map g; <Plug>(poslist-prev-pos)
map g, <Plug>(poslist-next-pos)

" nnoremap <Tab> gt
" nnoremap <S-Tab> gT
nnoremap <silent> <S-t> :tabnew<CR>

"*****************************************************************************
" <leader>
"*****************************************************************************
" Map leader to ,
" let mapleader=','
let mapleader = "\<Space>"

" 左手だけでコピーアンドペーストができるように
noremap <leader>c y
vnoremap <leader>c y
noremap <leader>v p
vnoremap <leader>v p
noremap <leader>z u
noremap <leader>Z <C-r>


" <Leader>a
" <Leader>b
" <Leader>c : quickfix用のプレフィックス
map <leader>cl :cclose<CR>
map <leader>co :copen<CR>

" buffer
noremap <leader>w :bn<CR>
noremap <leader>q :bp<CR>
noremap <leader>d :bd<CR>

" カーソル位置の単語選択
" noremap <leader>e viw
" カーソル位置の単語ヤンク
noremap <leader>e yiw
vnoremap <leader>e y

" ダブルクォートの中身を選択
" noremap <leader>e vi"
" va" → a : a : ダブルクォートを含んだ検索
" noremap <leader>e va"
" vi"p : ダブルクォートの中身を選択した後、ペースト
" noremap <leader>e vi"p

"<Leader><Leader>で変更があれば保存
noremap <Leader><Leader> :up<CR>

" ScrExpl
" nnoremap <Leader>o :SrcExplToggle<CR>

" savevers.vim VersDiffから抜ける
noremap <Leader>vq :VersDiff -c<CR>

" memolist.vim
map <Leader>'n  :MemoNew<CR>
map <Leader>'l  :MemoList<CR>
map <Leader>'g  :MemoGrep<CR>

" vim-easymotion
" JK motions: Line motions
"# keep cursor colum JK motion
let g:EasyMotion_startofline = 0
" nmap <Leader>j <Plug>(easymotion-j)
" vmap <Leader>j <Plug>(easymotion-j)
" nmap <Leader>k <Plug>(easymotion-k)
" vmap <Leader>k <Plug>(easymotion-k)
nmap <Leader>j <Plug>(easymotion-sol-j)
vmap <Leader>j <Plug>(easymotion-sol-j
nmap <Leader>k <Plug>(easymotion-sol-k)
vmap <Leader>k <Plug>(easymotion-sol-k)

nmap <Leader>l <Plug>(easymotion-w)
vmap <Leader>l <Plug>(easymotion-w)
nmap <Leader>h <Plug>(easymotion-b)
vmap <Leader>h <Plug>(easymotion-b)

" nmap <Leader>; <Plug>(easymotion-jumptoanywhere)
" vmap <Leader>; <Plug>(easymotion-jumptoanywhere)

" Bi-directional find motion
" Jump to anywhere you want with minimal keystrokes, with just one key binding.
" `s{char}{label}`
nmap <leader>s <Plug>(easymotion-s)

" or
" `s{char}{char}{label}`
" Need one more keystroke, but on average, it may be more comfortable.
" nmap <leader>s <Plug>(easymotion-s2)

" Quickfixウィンドウの開閉をトグルするAdd Star
function! s:toggle_quickfix_window()
  for _ in range(1, winnr('$'))
    execute _ . 'wincmd w'
    if &l:filetype ==# 'qf'
      close
      return
    endif
  endfor
  cwindow
endfunction
nnoremap <silent> <Leader>9 :<C-u>call <SID>toggle_quickfix_window()<CR>
"=============================================================================
" The prefix key.
"=============================================================================
nnoremap [Tag] <Nop>
nmap    t [Tag]

nnoremap [Tag]t <C-]>
nnoremap <silent> [Tag]n :<C-u>tag<CR>
nnoremap <silent> [Tag]p :<C-u>pop<CR>
nnoremap <silent> [Tag]l :<C-u>tags<CR>

"=============================================================================
" C-[a~z]
"=============================================================================
" <C-G> grep
nmap <C-G> :vimgrep /<C-R><C-W>/j %

" vim-poslist 戻る
" map <C-o> <Plug>(poslist-prev-pos)
" vim-poslist 次へ
" map <C-i> <Plug>(poslist-next-pos)

"=============================================================================
" Function Key map
"=============================================================================
" ------------------------------------------
" F[1~12]
" ------------------------------------------
" <F1> Vim Help
" <F2>
" <F3> カーソルがある行から [count] 個先の小文字のマークがある行の最初の非空白文字へ移動します。{Vi にはありません}
" nnoremap <F3> :<C-u>call <SID>AutoMarkrement_NextJump()<CR>
" <F4>

" <F5>
" map <silent> <F5> :NERDTree b:projectlocal_root_dir

" <F6> SrcExpl.vim
" nnoremap <F6> :SrcExplToggle<CR>

" <F6>

" <F7> 前の該当位置へジャンプ
nnoremap <F7> :cprevious <CR>

" <F8> 次の該当位置へジャンプ
nnoremap <F8> :cnext <CR>

" <F9>

" <F10>
" noremap <F3> :NERDTreeToggle<CR>
nnoremap <silent> <F10> :NERDTreeFind<CR>
" <F11>
" <F12> 検索結果の表示()
nnoremap <F12> <C-]>
" ------------------------------------------
" S-F[1~12]
" ------------------------------------------
" <S-F1>
" <S-F2>
" <S-F3>
" カーソル位置より [count] 個前の小文字のマークへ移動します。{Vi にはありません}
" nnoremap <silent> <S-F3> :NERDTreeFind<CR>
" nnoremap <S-F3> :<C-u>call <SID>AutoMarkrement_PreJump()<CR>
" <S-F4> Template
nnoremap <S-F4> :Template<Space>
" <S-F5>
" nmap <S-F5> :ls<CR>:b
map <silent> <S-F5> :call BufferList()<CR>
" <S-F6>
" <S-F7>  savevers.vim ひとつ前のバックアップと比較
nnoremap <S-F7> :VersDiff -<CR>
" <S-F8> savevers.vim ひとつ後のバックアップと比較
nnoremap <S-F8> :VersDiff +<CR>
" <S-F9> savevers.vim VersDiffから抜ける
nnoremap <S-F9> :VersDiff -C<CR>
" <S-F10>
" <S-F11> 現在開いているすべてのバッファからgrep
"         見えているバッファからgrepする場合は、bufdoの代わりにwindoを使う
"         実行するたびにQuickfixが追加されてしまうので、 cexpr "" を実行すること
nnoremap <S-F11> :bufdo vimgrepadd /<C-R><C-K>/j **/* %<CR>
" <S-F12> カーソル位置の単語でgrep
nnoremap <S-F12> :vimgrep /<C-R><C-W>/j **/*

" ------------------------------------------
" C-F[1~12]
" ------------------------------------------
" <C-F1>help
" <C-F2>
" :map <unique> <C-F3> <Plug>Vm_toggle_sign
" <C-F3>
" <C-F4>
" <C-F5>
" <C-F6>
" <C-F7>
" <C-F8>
" <C-F9>
" <C-F10>
" <C-F11>
" <C-F12>
" ------------------------------------------
" M-F[1~12]
" ------------------------------------------
" <M-F1>
" <M-F2>
" <M-F3>
" <M-F4>
" <M-F5>
" <M-F6>
" <M-F7>
" <M-F8>
" <M-F9>
" <M-F10>
" <M-F11>
" <M-F12>
" ------------------------------------------
" S-C-F[1~12]
" ------------------------------------------
" <S-C-F1>
" <S-C-F2>
" <S-C-F3>
" <S-C-F4>
" <S-C-F5>
" <S-C-F6>

" <S-C-F7> exjumplist
" nmap <S-C-F7>  <Plug>(exjumplist-previous-buffer)

" <S-C-F8> exjumplist
" nmap <S-C-F8>  <Plug>(exjumplist-next-buffer)

" <S-C-F9> exjumplist
" nmap <S-C-F9> <Plug>(exjumplist-go-last)

" <S-C-F10> exjumplist
" nmap <S-C-F10> <Plug>(exjumplist-go-first)

" <S-C-F11>
" <S-C-F12>
" ------------------------------------------
"  M-S-F[1~12]
" ------------------------------------------
" <M-S-F1>
" <M-S-F2>
" <M-S-F3>
" <M-S-F4>
" <M-S-F5>
" <M-S-F6>
" <M-S-F7>
" <M-S-F8>
" <M-S-F9>
" <M-S-F10>
" <M-S-F11>
" <M-S-F12>
" ------------------------------------------
"  M-C-F[1~12]
" ------------------------------------------
" <M-C-F1>
" <M-C-F2>
" <M-C-F3>
" <M-C-F4>
" <M-C-F5>
" <M-C-F6>
" <M-C-F7>
" <M-C-F8>
" <M-C-F9>
" <M-C-F10>
" <M-C-F11>
" <M-C-F12>
" ------------------------------------------
" C-S-M-F[1~12]
" ------------------------------------------
" <C-S-M-F1>
" <C-S-M-F2>
" <C-S-M-F3>
" <C-S-M-F4>
" <C-S-M-F5>
" <C-S-M-F6>
" <C-S-M-F7>
" <C-S-M-F8>
" <C-S-M-F9>
" <C-S-M-F10>
" <C-S-M-F11>
" <C-S-M-F12>
" ------------------------------------------
" D-F[1~12] MacのみCommandキー
" ------------------------------------------
"

"=============================================================================
" etc
"=============================================================================
" ノーマルモードでもエンターキーで改行を挿入
" noremap <CR> o<ESC>
"

" Mark用
if !exists('g:markrement_char')
  " let g:markrement_char = [
  " \     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
  " \     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
  " \ ]
  let g:markrement_char = [
        \     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        \     'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        \ ]
endif

if !exists('g:markrement_jump_pos')
  let g:markrement_jump_pos = 0
endif

" nnoremap <silent>m :<C-u>call <SID>AutoMarkrement()<CR>

function! s:AutoMarkrement()
  if !exists('b:markrement_mark_pos')
    let b:markrement_mark_pos = 0
    let g:markrement_jump_pos = 0
  else
    let b:markrement_mark_pos = (b:markrement_mark_pos + 1) % len(g:markrement_char)
    let g:markrement_jump_pos = (b:markrement_mark_pos + 1) % len(g:markrement_char)
  endif
  execute 'mark' g:markrement_char[b:markrement_mark_pos]
  echo 'marked' g:markrement_char[b:markrement_mark_pos]
endfunction

function! s:AutoMarkrement_NextJump()
  let g:markrement_jump_pos = (g:markrement_jump_pos + 1) % len(g:markrement_char)
  echo 'jump to ' . (g:markrement_char[g:markrement_jump_pos])
  execute 'normal `' . (g:markrement_char[g:markrement_jump_pos])
endfunction

function! s:AutoMarkrement_PreJump()
  execute 'normal `' . (g:markrement_char[g:markrement_jump_pos - 1] )
  echo 'jump to ' . (g:markrement_char[g:markrement_jump_pos - 1])
  if g:markrement_jump_pos <= 0
    let g:markrement_jump_pos = len(g:markrement_char) - 1
  else
    let g:markrement_jump_pos = (g:markrement_jump_pos - 1) % len(g:markrement_char)
  endif
endfunction


